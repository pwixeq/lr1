from logging import *


def bubble_sort(a):
    n = len(a)
    for i in range(n - 1):
        for j in range(n - 2, i - 1, -1):
            if a[j + 1] < a[j]:
                a[j], a[j + 1] = a[j + 1], a[j]

def bubble_sort_f(a):
    fl = True
    n = len(a)
    while fl:
        fl = False
        for i in range(n - 1):
            for j in range(n - 2, i - 1, -1):
                if a[j + 1] < a[j]:
                    a[j], a[j + 1] = a[j + 1], a[j]
                    fl = True


def choice_sort(a):
    n = len(a)
    for i in range(n - 1):
        im = i
        for j in range(i + 1, n):
            if a[j] < a[im]:
                im = j
        if im != i:
            a[i], a[im] = a[im], a[i]

def gnome_sort(a):
    x = len(a)
    for i in range(1, x):
        for j in range(i, 0, -1):
            if a[j] >= a[j - 1]:
                break
            a[j], a[j - 1] = a[j - 1], a[j]

def insert_sort(a):
    x = len(a)
    for i in range(1, x):
        t = a[i]
        j = i - 1
        while j >= 0 and a[j] > t:
            a[j + 1] = a[j]
            j -= 1
        a[j + 1] = t

def heap_sort(a):
    n = len(a)

    for i in range(n, -1, -1):
        heapify(a, n, i)

    for i in range(n - 1, 0, -1):
        a[i], a[0] = a[0], a[i]
        heapify(a, i, 0)


def merge_sort(arr, iterations=0):
    if len(arr) > 1:
        mid = len(arr) // 2
        l, iterations = merge_sort(arr[:mid], iterations)
        r, iterations = merge_sort(arr[mid:], iterations)
        arr, iters = merge(L, R)
        iterations += iters
    return arr, iterations

def merge(l, r):
    arr = []
    i = j = 0
    iterations = 0
    while i < len(l) and j < len(r):
        iterations += 1
        if l[i] < r[j]:
            arr.append(L[i])
            i += 1
        else:
            arr.append(R[j])
            j += 1
        logging.info(f"{arr[-1]}")
    arr.extend(l[i:] or r[j:])
    return arr, iterations

